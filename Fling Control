-- LocalScript in StarterPlayer > StarterPlayerScripts
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local cam = Workspace.CurrentCamera

local function getCharacter()
	local char = player.Character or player.CharacterAdded:Wait()
	local humanoid = char:WaitForChild("Humanoid")
	local root = char:WaitForChild("HumanoidRootPart")
	return humanoid, root, char
end

local humanoid, root, char = getCharacter()

-- Settings
local flingVelocityThreshold = 150
local sittingSpeedThreshold = 18
local bounceDamping = 0.8 -- < 1 = lose momentum (0.8 = keep 80% each bounce)
local ragdollStates = {
	Enum.HumanoidStateType.Physics,
	Enum.HumanoidStateType.FallingDown,
	Enum.HumanoidStateType.Ragdoll,
}

local ragdolled = false
local flinging = false
local sitting = false

-- Detect ragdoll states
humanoid.StateChanged:Connect(function(_, new)
	ragdolled = false
	for _, s in ipairs(ragdollStates) do
		if new == s then
			ragdolled = true
			break
		end
	end
end)

-- Detect sitting
humanoid:GetPropertyChangedSignal("Sit"):Connect(function()
	sitting = humanoid.Sit
end)

-- Determine if fling logic should be active
local function shouldFling()
	if not root then return false end
	local vel = root.Velocity
	local horizontalSpeed = Vector3.new(vel.X, 0, vel.Z).Magnitude
	return ragdolled or vel.Magnitude > flingVelocityThreshold or (sitting and horizontalSpeed > sittingSpeedThreshold)
end

-- Redirect fling momentum instantly
RunService.Heartbeat:Connect(function()
	if root and shouldFling() then
		flinging = true
		local vel = root.Velocity
		local horizontalSpeed = Vector3.new(vel.X, 0, vel.Z).Magnitude

		-- Redirect horizontal velocity to camera direction
		local look = cam.CFrame.LookVector
		local flatLook = Vector3.new(look.X, 0, look.Z)

		if flatLook.Magnitude > 0 then
			flatLook = flatLook.Unit
			local newVel = flatLook * horizontalSpeed
			root.Velocity = Vector3.new(newVel.X, vel.Y, newVel.Z)
		end
	else
		flinging = false
	end
end)

-- Bounce with damping (no infinite speed gain)
local function setupBounce(char, rootPart)
	for _, part in ipairs(char:GetDescendants()) do
		if part:IsA("BasePart") and part ~= rootPart then
			part.Touched:Connect(function(hit)
				if flinging and hit.CanCollide and not hit:IsDescendantOf(char) then
					local vel = rootPart.Velocity
					if vel.Y < -5 then
						-- Raycast to get surface normal
						local rayOrigin = rootPart.Position
						local rayDir = Vector3.new(0, -5, 0)
						local raycastParams = RaycastParams.new()
						raycastParams.FilterDescendantsInstances = {char}
						raycastParams.FilterType = Enum.RaycastFilterType.Exclude

						local result = Workspace:Raycast(rayOrigin, rayDir, raycastParams)
						if result then
							local normal = result.Normal
							local reflection = vel - 2 * vel:Dot(normal) * normal
							-- Apply damping so you lose momentum each bounce
							rootPart.Velocity = reflection * bounceDamping
						else
							-- fallback: straight up with damping
							rootPart.Velocity = Vector3.new(vel.X, math.abs(vel.Y) * bounceDamping, vel.Z)
						end
					end
				end
			end)
		end
